import{s as se,ab as A,z as c,fL as Z,n as v,fE as ge,fB as be,ai as R,dW as xe,cu as ee,dX as ne,g as ve,gF as he,gG as Te}from"./index-c754ff65.js";import{L as C,S as g,V as Fe}from"./color-6aec3839.js";import{c as Se}from"./utils-7263c34f.js";import{l as we}from"./visualVariablesUtils-7dbd5d40.js";import{createSymbolSchema as b}from"./createSymbolSchema-21e81f0c.js";import"./cimAnalyzer-02b56dc2.js";import"./alignmentUtils-ae955d28.js";import"./mat2d-e11be45e.js";import"./vec2-bbd3449a.js";import"./TileStrategy-1967197e.js";import"./number-b10bd8f5.js";import"./ExpandedCIM-2a6dd26b.js";import{l as _}from"./capabilities-57d1a30a.js";import{e as le}from"./util-e5019f71.js";function oe(e){if(!e)return C.NONE;let i=0;for(const r of e)if(r.type==="size"){const t=we(r);i|=t,r.target==="outline"&&(i|=t<<4)}else r.type==="color"?i|=C.COLOR:r.type==="opacity"?i|=C.OPACITY:r.type==="rotation"&&(i|=C.ROTATION);return i}function Ee(e,i){if(!("visualVariables"in e)||!e.hasVisualVariables("size"))return 0;const r=e.getVisualVariablesForType("size");if(!r[0])return 0;const t=r[0];if(i&&t.field==="cluster_count"&&i.type==="cluster")return i.clusterMaxSize;if(t.target==="outline")return 0;if(t.transformationType==="stops")return t.stops.map(s=>s.size).reduce(P,0);if(t.transformationType==="clamped-linear"){let s=-1/0,n=-1/0;return s=typeof t.maxSize=="number"?t.maxSize:t.maxSize.stops.map(l=>l.size).reduce(P,0),n=typeof t.minSize=="number"?t.minSize:t.minSize.stops.map(l=>l.size).reduce(P,0),Math.max(s,n)}return t.transformationType==="real-world-size"?30:void 0}function P(e,i){return Math.max(e,i)}const D=8,ae=D-2,k=se.getLogger("esri.views.2d.layers.features.support.rendererUtils"),ot=e=>{if(!("visualVariables"in e)||!e.visualVariables||!e.visualVariables.length)return e;const i=e.clone(),r=i.visualVariables.map(t=>ue(t)?pe(t):t);return i.visualVariables=r,i};function Ie(e){return e.map(i=>ue(i)?pe(i.clone()):i)}function ue(e){return(e.type==="size"||e.type==="color"||e.type==="opacity")&&e.stops!=null}function pe(e){return e.stops=Oe(e.type,e.stops??[]),e}function V(e,i,r){return(1-r)*e+r*i}function Ve(e,i){const[r,...t]=i,s=t.pop(),n=t[0].value,l=t[t.length-1].value,u=(l-n)/ae,a=[];for(let o=n;o<l;o+=u){let p=0;for(;o>=t[p].value;)p++;const f=t[p],d=i[p-1],z=o-d.value,S=f.value===d.value?1:z/(f.value-d.value);if(e==="color"){const x=t[p],h=i[p-1],y=x.color.clone();y.r=V(h.color.r,y.r,S),y.g=V(h.color.g,y.g,S),y.b=V(h.color.b,y.b,S),y.a=V(h.color.a,y.a,S),a.push({value:o,color:y,label:x.label})}else if(e==="size"){const x=t[p],h=i[p-1],y=Z(x.size),T=V(Z(h.size),y,S);a.push({value:o,size:T,label:x.label})}else{const x=t[p],h=V(i[p-1].opacity,x.opacity,S);a.push({value:o,opacity:h,label:x.label})}}return[r,...a,s]}function ze(e){const[i,...r]=e,t=r.pop();for(;r.length>ae;){let s=0,n=0;for(let l=1;l<r.length;l++){const u=r[l-1],a=r[l],o=Math.abs(a.value-u.value);o>n&&(n=o,s=l)}r.splice(s,1)}return[i,...r,t]}function Oe(e,i){return i.length<=D?i:(k.warn(`Found ${i.length} Visual Variable stops, but MapView only supports ${D}. Displayed stops will be simplified.`),i.length>2*D?Ve(e,i):ze(i))}function W(){if(A("heatmap-force-raster"))return"raster";const{supportsTextureFloat:e,supportsTextureHalfFloat:i,supportsColorBufferFloat:r,supportsColorBufferFloatBlend:t,supportsColorBufferHalfFloat:s}=_("2d");return e&&r&&t||i&&s?"symbol":A("heatmap-allow-raster-fallback")?"raster":"none"}function at(e){if(!e)return!0;switch(e.type){case"dot-density":if(!_("2d").supportsTextureFloat)return k.error(new c("webgl-missing-extension","Missing WebGL extension OES_Texture_Float which is required for DotDensity")),!1;break;case"heatmap":{const i=W();if(i==="none"||i==="raster"&&!A("heatmap-force-raster")){const r=_("2d"),t=["supportsTextureFloat","supportsTextureHalfFloat","supportsColorBufferFloat","supportsColorBufferFloatBlend","supportsColorBufferHalfFloat"].filter(s=>!r[s]).join(", ");if(i==="none")return k.errorOnce(new c("webgl-missing-extension",`Missing WebGL${r.type} requirements for Heatmap: ${t}`)),!1;i==="raster"&&k.warnOnce(`Missing WebGL${r.type} requirements for accelerated Heatmap: ${t}. Feature support may be limited.`)}break}}return!0}const E=se.getLogger("esri.views.2d.layers.features.schemaUtils"),m="ValidationError";function G(e,i){let r=0,t=0,s=g.DEFAULT;if(v(e)){if(t=Ee(e,i),"visualVariables"in e&&(r=oe(e.visualVariables||[]),e.type==="dot-density"&&(s=g.DOT_DENSITY)),e.type==="heatmap"&&(s=g.HEATMAP),e.type==="dictionary")return{maxVVSize:t,vvFlags:r,symbologyType:g.DEFAULT};if(e.type==="pie-chart")return{maxVVSize:t,vvFlags:r,symbologyType:g.PIE_CHART};if(s!==g.DOT_DENSITY&&s!==g.HEATMAP){const n=e.getSymbols();"backgroundFillSymbol"in e&&e.backgroundFillSymbol&&n.push(e.backgroundFillSymbol);let l=!0,u=!0;for(const a of n)if(a.type==="cim"&&(u=!1),a.type==="simple-fill"||a.type==="picture-fill"){const o=a.outline,p=o&&o.style!=="none"&&o.style!=="solid",f=a.type==="simple-fill"&&a.style!=="none"&&a.style!=="solid";p&&(l=!1),(a.type==="picture-fill"||f||p)&&(u=!1)}l?s=u?g.OUTLINE_FILL_SIMPLE:g.OUTLINE_FILL:u&&(s=g.SIMPLE)}}return{vvFlags:r,maxVVSize:t,symbologyType:s}}let te=null;function ut(e){if(A("esri-2d-update-debug")){const i=re(e,!0);console.debug("Created new schema",i),console.debug("Schema diff",be(te,i)),te=i}return re(e)}function re(e,i=!1){var r,t;try{const s=Be(e,i),n=Re(e),l={};s.map(o=>Me(l,e,o));const u=v(e.subtypeCode)?`${e.subtypeField} = ${e.subtypeCode}`:null;return{source:{definitionExpression:R(xe(e.definitionExpression,u)),fields:e.fields.map(o=>o.toJSON()),gdbVersion:e.gdbVersion,historicMoment:(r=e.historicMoment)==null?void 0:r.getTime(),outFields:e.availableFields,pixelBuffer:e.pixelBuffer,spatialReference:e.spatialReference.toJSON(),timeExtent:(t=e.timeExtent)==null?void 0:t.toJSON(),customParameters:e.customParameters},attributes:{fields:{},indexCount:0},processors:s,tileRenderer:n,targets:l}}catch(s){if(s.fieldName===m)return E.error(s),null;throw s}}function Me(e,i,r){switch(r.target){case"feature":return void J(e,H(i),r);case"aggregate":{if(!("featureReduction"in i))return;const t=i.featureReduction;switch(t==null?void 0:t.type){case"selection":throw new c(m,"Mapview does not support `selection` reduction type",t);case"binning":return J(e,H(i),r),void Le(e,t,i.fields.map(s=>s.toJSON()),r);case"cluster":return J(e,H(i),r),void Ne(e,t,i.fields.map(s=>s.toJSON()),r)}}}}function Y(e,i){var r,t;for(const s in i){const n=i[s];if(n.target!==e.name)continue;const l=e.attributes[s];if(l!=null&&l.context){const u=l.context;u.mesh=u.mesh||((r=n.context)==null?void 0:r.mesh),u.storage=u.storage||((t=n.context)==null?void 0:t.storage)}else e.attributes[s]=n}return e}function H(e){var i,r,t;return[((i=R(e.filter))==null?void 0:i.toJSON())??null,((t=R((r=R(e.featureEffect))==null?void 0:r.filter))==null?void 0:t.toJSON())??null]}function J(e,i,r){return e.feature||(e.feature={name:"feature",input:"source",filters:i,attributes:{}}),Y(e.feature,r.attributes.fields),e}function fe(e,i){const{onStatisticExpression:r,onStatisticField:t,statisticType:s}=e;switch(s){case"min":case"max":case"avg":case"avg_angle":case"sum":case"count":return"esriFieldTypeDouble";case"mode":{if(r){const{returnType:l}=r;return l?l==="string"?"esriFieldTypeString":"esriFieldTypeDouble":(E.error(new c(m,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",e)),"esriFieldTypeString")}const n=i.find(l=>l.name===t);return n?n.type:(E.error(new c(m,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",e)),"esriFieldTypeString")}}}function Le(e,i,r,t){return e.aggregate||(e.aggregate={name:"aggregate",type:"bin",filters:null,input:"feature",params:{fixedBinLevel:i.fixedBinLevel,fields:(i.fields??[]).map(s=>({...s.toJSON(),type:fe(s,r)}))},attributes:{}}),Y(e.aggregate,t.attributes.fields),e}function Ne(e,i,r,t){var s;return e.aggregate||(e.aggregate={name:"aggregate",type:"cluster",input:"feature",filters:null,attributes:{},params:{clusterRadius:ee(i.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(ee(i.clusterMaxSize)/64),fields:(s=i.fields??[])==null?void 0:s.map(n=>({...n.toJSON(),type:fe(n,r)}))}}),Y(e.aggregate,t.attributes.fields),e}function F(e,i){return i.field?w(e,{...i,type:"field",field:i.field}):i.valueExpression?w(e,{...i,type:"expression",valueExpression:i.valueExpression}):{field:void 0,fieldIndex:void 0}}function w(e,i){switch(i.type){case"expression":{const r=i.valueExpression;if(!e.fields[r]){const t=e.indexCount++;e.fields[r]={...i,name:r,fieldIndex:t}}return{fieldIndex:e.fields[r].fieldIndex}}case"label-expression":{const r=JSON.stringify(i.label);if(!e.fields[r]){const t=e.indexCount++;e.fields[r]={...i,name:r,fieldIndex:t}}return{fieldIndex:e.fields[r].fieldIndex}}case"field":{const r=i.field;return i.target==="aggregate"&&e.fields[r]||(e.fields[r]={...i,name:r}),{field:r}}case"statistic":return e.fields[i.name]={...i},{field:i.name}}}function Be(e,i=!1){const r=new Array;let t=0;return r.push(Ce(e,t++,i)),r}function U(e,i,r,t,s,n=!1){const l=w(e,{type:"label-expression",target:r,context:{mesh:!0},resultType:"string",label:{labelExpression:i.labelExpression,labelExpressionInfo:i.labelExpressionInfo?{expression:i.labelExpressionInfo.expression}:null,symbol:!!i.symbol,where:i.where}}),{fieldIndex:u}=l;return{...b(i,s,n),fieldIndex:u,target:r,index:t}}function $e(e,i,r){var p;const t="featureReduction"in i&&i.featureReduction;if(!t)return{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};const s="aggregate",n=[];let l=null,u=le(i.geometryType),a=[],o=null;if(t)switch(t.type){case"selection":return E.error(new c(m,"Mapview does not support `selection` reduction type",t)),{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};case"cluster":case"binning":if(n.push(...t.fields??[]),t.type==="cluster"?u="esriGeometryPoint":t.type==="binning"&&(u="esriGeometryPolygon"),t.renderer&&!((p=t.renderer.authoringInfo)!=null&&p.isAutoGenerated)){if(t.type==="cluster"){const{renderer:d}=he(t.renderer,t,null);o=d}else o=t.renderer;const f=G(t.renderer,t);l=q(e,s,t.renderer,f,r),a=t&&t.labelsVisible&&t.labelingInfo||[]}else if(t.type==="cluster"){if(o=Te(n,i.renderer,t,null,!0),t.symbol){const f=G(o,t);l={type:"simple",symbol:b(t.symbol,f,r),symbologyType:f.symbologyType}}a=t&&t.labelsVisible&&t.labelingInfo||[]}}return ke(e,n),{labels:ne(a,t.type==="binning"?"esriGeometryPolygon":u),matcher:l,fields:n,rendererOverride:o}}function Ce(e,i,r=!1){var y;const t={indexCount:0,fields:{}},s="featureReduction"in e?e.featureReduction??void 0:void 0,n=s?"aggregate":"feature";if("sublayers"in e){const T={type:"subtype",subtypeField:e.subtypeField,renderers:{},symbologyType:g.DEFAULT},B={type:"subtype",mapping:{},target:"feature",subtypeField:e.subtypeField},$={type:"subtype",classes:{}},de={type:"symbol",target:"feature",aggregateFields:[],attributes:t,storage:B,mesh:{matcher:T,aggregateMatcher:null,labels:$,sortKey:null}},K=new Set;let ce=0;for(const{renderer:I,subtypeCode:O,labelingInfo:ye,labelsVisible:me}of e.sublayers){let j=0;"visualVariables"in I&&I.visualVariables&&(I.visualVariables.some(N=>N.type!=="rotation")&&E.warnOnce("SubtypeGroupLayer currently only supports rotation visualVariables. All other visualVariable types will be ignored."),j=oe(I.visualVariables.filter(N=>N.type!=="size")));const X={symbologyType:g.DEFAULT,vvFlags:j,maxVVSize:0},M=q(t,n,I,X,r),L=ie(t,n,I),Q=me&&ye;if(M.type==="dictionary")throw new c(m,"Dictionary renderer is not supported in subtype layers");if(M.type==="subtype")throw new c(m,"Nested subtype renderers is not supported");if(v(L)&&L.type==="subtype")throw new c(m,"Nested subtype storage is not supported");if(v(L)&&v(L.attributeMapping))throw new c(m,"Non-visual-variable attributes are not supported in subtype layers");if(M.type==="heatmap")throw new c(m,"Heatmaps are not supported in subtype layers");if(M.type==="pie-chart")throw new c(m,"Pie-charts are not supported in subtype layers");if(K.has(O))throw new c(m,"Subtype codes for sublayers must be unique");K.add(O),T.renderers[O]=M,B.mapping[O]=L,Q&&($.classes[O]=Q.map(N=>U(t,N,"feature",ce++,X,r)))}return de}if(((y=e.renderer)==null?void 0:y.type)==="heatmap"&&W()==="raster"){const{radius:T,fieldOffset:B,field:$}=e.renderer;return{type:"heatmap",aggregateFields:[],attributes:t,target:n,storage:null,mesh:{radius:T,fieldOffset:B,field:F(t,{target:n,field:$,resultType:"numeric"}).field}}}const l=$e(t,e,r),u=le(e.geometryType),a=l.rendererOverride??e.renderer,o=G(a,s),p=q(t,n,a,o,r),f=ie(t,n,a),d=De(t,e.orderBy,e.renderer,s),z=e.labelsVisible&&e.labelingInfo||[],S=ne(z,u);let x=0;const h=[...S.map(T=>U(t,T,"feature",x++,o,r)),...l.labels.map(T=>U(t,T,"aggregate",x++,o,r))];return{type:"symbol",target:n,attributes:t,aggregateFields:l.fields,storage:f,mesh:{matcher:p,labels:{type:"simple",classes:h},aggregateMatcher:l.matcher,sortKey:d}}}function Re(e){var i;return((i=e.renderer)==null?void 0:i.type)==="heatmap"&&W()==="raster"?{type:"heatmap"}:{type:"symbol"}}function De(e,i,r,t){if(v(t))return null;if(v(i)&&i.length){i.length>1&&E.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${i.length}. All but the first will be discarded`);const s=i[0],n=s.order==="ascending"?"asc":"desc";return s.field?{field:s.field,order:n}:s.valueExpression?{fieldIndex:w(e,{type:"expression",target:"feature",valueExpression:s.valueExpression,resultType:"numeric"}).fieldIndex,order:n}:(E.error(new c(m,"Expected to find a field or valueExpression for OrderByInfo",s)),null)}return v(r)&&r.type==="unique-value"&&r.orderByClassesEnabled?{byRenderer:!0,order:"asc"}:null}function ke(e,i){const r={mesh:!0,storage:!0};for(const t of i){const{name:s,onStatisticField:n,onStatisticExpression:l,statisticType:u}=t;let a,o;const p="numeric",f="feature";l?o=w(e,{type:"expression",target:f,valueExpression:l.expression,resultType:p}).fieldIndex:a=w(e,{type:"field",target:f,field:n,resultType:p}).field,w(e,{type:"statistic",target:"aggregate",name:s,context:r,inField:a,inFieldIndex:o,statisticType:u})}}function ie(e,i,r){let t;switch(r.type){case"simple":case"class-breaks":case"unique-value":case"dictionary":t={visualVariables:!0,attributes:null};break;default:t=Se(r).getStorageSpec(r)}return Ae(e,i,t,r)}function Ae(e,i,r,t){if(ve(r))return null;const{visualVariables:s,attributes:n}=r;let l=null;s&&"visualVariables"in t&&(l=Pe(e,i,t.visualVariables));const u=v(l)?4:0;let a=null;return v(n)&&(a=n.map((o,p)=>{const{field:f,fieldIndex:d}=F(e,{valueExpression:o.valueExpression,field:o.field,resultType:"numeric",target:i});return{binding:p+u,field:f,fieldIndex:d}})),{type:"simple",target:i,attributeMapping:a,vvMapping:l}}function Pe(e,i,r){if(!r||!r.length)return[];const t={storage:!0},s="numeric";return Ie(r).map(n=>{const l=Fe(n.type),{field:u,fieldIndex:a}=F(e,{target:i,valueExpression:n.valueExpression,field:n.field,context:t,resultType:s});switch(n.type){case"size":return n.valueExpression==="$view.scale"?null:{type:"size",binding:l,field:u,fieldIndex:a,normalizationField:F(e,{target:i,field:n.normalizationField,context:t,resultType:s}).field,valueRepresentation:n.valueRepresentation??null};case"color":return{type:"color",binding:l,field:u,fieldIndex:a,normalizationField:F(e,{target:i,field:n.normalizationField,context:t,resultType:s}).field};case"opacity":return{type:"opacity",binding:l,field:u,fieldIndex:a,normalizationField:F(e,{target:i,field:n.normalizationField,context:t,resultType:s}).field};case"rotation":return{type:"rotation",binding:l,field:u,fieldIndex:a}}}).filter(v)}function q(e,i,r,t,s=!1){const n=ge(e,{indexCount:0,fields:{}});switch(r.type){case"simple":case"dot-density":return He(n,r,t,s);case"class-breaks":return Ue(n,i,r,t,s);case"unique-value":return _e(n,i,r,t,s);case"dictionary":return Ge(n,r,t,s);case"heatmap":return qe(n,r,t,s);case"pie-chart":return Je(n,r,t,s)}}function He(e,i,r,t=!1){const s=i.getSymbols(),n=s.length?s[0]:null;return{type:"simple",symbol:b(n,r,t),symbologyType:r.symbologyType}}function Je(e,i,r,t=!1){const s=i.getSymbols(),n=s[0],l=s.length>1?s[1]:null;return{type:"pie-chart",markerSymbol:b(n,r,t),fillSymbol:b(l,r,t),symbologyType:r.symbologyType}}function Ue(e,i,r,t,s=!1){const n={mesh:!0,use:"renderer.field"},l=r.backgroundFillSymbol,{field:u,fieldIndex:a}=F(e,{target:i,field:r.field,valueExpression:r.valueExpression,resultType:"numeric",context:n}),o=r.normalizationType,p=o==="log"?"esriNormalizeByLog":o==="percent-of-total"?"esriNormalizeByPercentOfTotal":o==="field"?"esriNormalizeByField":null,f=r.classBreakInfos.map(d=>({symbol:b(d.symbol,t,s),min:d.minValue,max:d.maxValue})).sort((d,z)=>d.min-z.min);return{type:"interval",attributes:e.fields,field:u,fieldIndex:a,backgroundFillSymbol:b(l,t,s),defaultSymbol:b(r.defaultSymbol,t,s),intervals:f,normalizationField:r.normalizationField,normalizationTotal:r.normalizationTotal,normalizationType:p,isMaxInclusive:r.isMaxInclusive,symbologyType:t.symbologyType}}function _e(e,i,r,t,s=!1){const n=[],l=r.backgroundFillSymbol,u={target:i,context:{mesh:!0},resultType:"string"};if(r.field&&typeof r.field!="string")throw new c(m,"Expected renderer.field to be a string",r);const{field:a,fieldIndex:o}=F(e,{...u,field:r.field,valueExpression:r.valueExpression});for(const p of r.uniqueValueInfos??[])n.push({value:""+p.value,symbol:b(p.symbol,t,s)});return{type:"map",attributes:e.fields,field:a,fieldIndex:o,field2:F(e,{...u,field:r.field2}).field,field3:F(e,{...u,field:r.field3}).field,fieldDelimiter:r.fieldDelimiter??void 0,backgroundFillSymbol:b(l,t),defaultSymbol:b(r.defaultSymbol,t),map:n,symbologyType:t.symbologyType}}function Ge(e,i,r,t=!1){return{type:"dictionary",config:i.config,fieldMap:i.fieldMap,scaleExpression:i.scaleExpression,url:i.url,symbolOptions:r,symbologyType:r.symbologyType}}function qe(e,i,r,t=!1){const s=i.getSymbols(),n=s.length?s[0]:null;return{type:"heatmap",symbol:b(n,r,t),symbologyType:r.symbologyType}}export{q as $,ut as I,at as h,ot as n,G as w};
