import{cO as k,U as X,bz as F,bM as V,s as W,bV as Z,g as _,aZ as C,ca as A,n as B,ah as v,b2 as I,dr as E,z as G}from"./index-1de34779.js";import{r as N,o as O,i as R,s as D}from"./normalizeUtilsCommon-5bd32cf4.js";import{f as H,r as K,o as Q}from"./utils-fd07bdbf.js";async function Y(t,s,f,n){const e=H(t),c=s[0].spatialReference,a={...n,query:{...e.query,f:"json",sr:JSON.stringify(c),target:JSON.stringify({geometryType:k(s[0]),geometries:s}),cutter:JSON.stringify(f)}},o=await X(e.path+"/cut",a),{cutIndexes:u,geometries:y=[]}=o.data;return{cutIndexes:u,geometries:y.map(h=>{const x=F(h);return x.spatialReference=c,x})}}async function tt(t,s,f){const n=typeof t=="string"?V(t):t,e=s[0].spatialReference,c=k(s[0]),a={...f,query:{...n.query,f:"json",sr:e.wkid?e.wkid:JSON.stringify(e),geometries:JSON.stringify(K(s))}},{data:o}=await X(n.path+"/simplify",a);return Q(o.geometries,c,e)}const T=W.getLogger("esri.geometry.support.normalizeUtils");function et(t){return t.type==="polygon"}function st(t){return t[0].type==="polygon"}function nt(t){return t[0].type==="polyline"}function ot(t,s){if(!(t instanceof A||t instanceof I)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw T.error(e),new G(e)}const f=O(t),n=[];for(const e of f){const c=[];n.push(c),c.push([e[0][0],e[0][1]]);for(let a=0;a<e.length-1;a++){const o=e[a][0],u=e[a][1],y=e[a+1][0],h=e[a+1][1],x=Math.sqrt((y-o)*(y-o)+(h-u)*(h-u)),l=(h-u)/x,m=(y-o)/x,p=x/s;if(p>1){for(let b=1;b<=p-1;b++){const M=b*s,r=m*M+o,i=l*M+u;c.push([r,i])}const $=(x+Math.floor(p-1)*s)/2,S=m*$+o,U=l*$+u;c.push([S,U])}c.push([y,h])}}return et(t)?new I({rings:n,spatialReference:t.spatialReference}):new A({paths:n,spatialReference:t.spatialReference})}function J(t,s,f){if(s){const n=ot(t,1e6);t=E(n,!0)}return f&&(t=D(t,f)),t}function P(t,s,f){if(Array.isArray(t)){const n=t[0];if(n>s){const e=R(n,s);t[0]=n+e*(-2*s)}else if(n<f){const e=R(n,f);t[0]=n+e*(-2*f)}}else{const n=t.x;if(n>s){const e=R(n,s);t=t.clone().offset(e*(-2*s),0)}else if(n<f){const e=R(n,f);t=t.clone().offset(e*(-2*f),0)}}return t}function rt(t,s){let f=-1;for(let n=0;n<s.cutIndexes.length;n++){const e=s.cutIndexes[n],c=s.geometries[n],a=O(c);for(let o=0;o<a.length;o++){const u=a[o];u.some(y=>{if(y[0]<180)return!0;{let h=0;for(let l=0;l<u.length;l++){const m=u[l][0];h=m>h?m:h}h=Number(h.toFixed(9));const x=-360*R(h,180);for(let l=0;l<u.length;l++){const m=c.getPoint(o,l);c.setPoint(o,l,m.clone().offset(x,0))}return!0}})}if(e===f){if(st(t))for(const o of O(c))t[e]=t[e].addRing(o);else if(nt(t))for(const o of O(c))t[e]=t[e].addPath(o)}else f=e,t[e]=c}return t}async function it(t,s,f){if(!Array.isArray(t))return it([t],s);s&&typeof s!="string"&&T.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:(s==null?void 0:s.url)??Z.geometryServiceUrl;let e,c,a,o,u,y,h,x,l=0;const m=[],p=[];for(const r of t)if(_(r))p.push(r);else if(e||(e=r.spatialReference,c=C(e),a=e.isWebMercator,y=a?102100:4326,o=N[y].maxX,u=N[y].minX,h=N[y].plus180Line,x=N[y].minus180Line),c)if(r.type==="mesh")p.push(r);else if(r.type==="point")p.push(P(r.clone(),o,u));else if(r.type==="multipoint"){const i=r.clone();i.points=i.points.map(g=>P(g,o,u)),p.push(i)}else if(r.type==="extent"){const i=r.clone()._normalize(!1,!1,c);p.push(i.rings?new I(i):i)}else if(r.extent){const i=r.extent,g=R(i.xmin,u)*(2*o);let d=g===0?r.clone():D(r.clone(),g);i.offset(g,0),i.intersects(h)&&i.xmax!==o?(l=i.xmax>l?i.xmax:l,d=J(d,a),m.push(d),p.push("cut")):i.intersects(x)&&i.xmin!==u?(l=i.xmax*(2*o)>l?i.xmax*(2*o):l,d=J(d,a,360),m.push(d),p.push("cut")):p.push(d)}else p.push(r.clone());else p.push(r);let $=R(l,o),S=-90;const U=$,b=new A;for(;$>0;){const r=360*$-180;b.addPath([[r,S],[r,-1*S]]),S*=-1,$--}if(m.length>0&&U>0){const r=rt(m,await Y(n,m,b,f)),i=[],g=[];for(let w=0;w<p.length;w++){const q=p[w];if(q!=="cut")g.push(q);else{const L=r.shift(),z=t[w];B(z)&&z.type==="polygon"&&z.rings&&z.rings.length>1&&L.rings.length>=z.rings.length?(i.push(L),g.push("simplify")):g.push(a?v(L):L)}}if(!i.length)return g;const d=await tt(n,i,f),j=[];for(let w=0;w<g.length;w++){const q=g[w];q!=="simplify"?j.push(q):j.push(a?v(d.shift()):d.shift())}return j}const M=[];for(let r=0;r<p.length;r++){const i=p[r];if(i!=="cut")M.push(i);else{const g=m.shift();M.push(a===!0?v(g):g)}}return M}function lt(t,s){const f=C(s);if(f){const[n,e]=f.valid,c=e-n;if(t<n)for(;t<n;)t+=c;if(t>e)for(;t>e;)t-=c}return t}export{lt as U,it as v};
