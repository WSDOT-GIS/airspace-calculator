import{e as g,y as _,a as G,v as X,b as j}from"./index-c754ff65.js";import{m as Q,b as R}from"./vec2-bbd3449a.js";import{l as U,a as A}from"./TileInfoView-ccee1155.js";import{u as Y,R as ee}from"./aaBoundingRect-5c57438c.js";import{e as te}from"./TileKey-b1f5cdb9.js";function W(){return new Float32Array(2)}function se(n){const e=new Float32Array(2);return e[0]=n[0],e[1]=n[1],e}function N(n,e){const i=new Float32Array(2);return i[0]=n,i[1]=e,i}function ie(n,e){return new Float32Array(n,e,2)}function Z(){return W()}function D(){return N(1,1)}function H(){return N(1,0)}function J(){return N(0,1)}const re=Z(),ne=D(),oe=H(),le=J();Object.freeze(Object.defineProperty({__proto__:null,ONES:ne,UNIT_X:oe,UNIT_Y:le,ZEROS:re,clone:se,create:W,createView:ie,fromValues:N,ones:D,unitX:H,unitY:J,zeros:Z},Symbol.toStringTag,{value:"Module"}));function he(n,e){return n.length=0,e.forEach(i=>n.push(i)),n}const M=new Set,x=[],P=new Map,B=[0,0];let k=class extends X{constructor(e){super(e),this._keyToItem=new Map,this.concurrency=6,this.strategy="scale-first",this.tileInfoView=null}initialize(){const{concurrency:e,process:i}=this;this._queue=new U({concurrency:e,process:(s,t)=>{const r=this._keyToItem.get(s);return i(r,{signal:t})},peeker:s=>s.values().next().value})}destroy(){this.clear(),this._queue=j(this._queue)}get length(){return this._queue?this._queue.length:0}get onGoingCount(){return this._keyToItem.size}get updating(){return this.length>0||this.onGoingCount>0}abort(e){const i=typeof e=="string"?e:e.id;this._queue.abort(i)}clear(){this._queue.clear(),this._keyToItem.clear(),this.notifyChange("updating")}has(e){return typeof e=="string"?this._keyToItem.has(e):this._keyToItem.has(e.id)}isOngoing(e){const i=typeof e=="string"?e:e.id;return this.has(i)&&this._queue.isOngoing(i)}pause(){this._queue.pause()}push(e,i){const s=e.key.id+"-"+i;if(this.has(s))return this.get(s);const t=this._queue.push(s),r=()=>{this._keyToItem.delete(s),this.notifyChange("updating")};return this._keyToItem.set(s,e),t.then(r,r),this.notifyChange("updating"),t}reset(){this._queue.reset(),this.notifyChange("updating")}resume(){this._queue.resume()}_peekByScaleFirst(e){if(!this.state)return e.values().next().value;const i=this.tileInfoView;let s=Number.NEGATIVE_INFINITY,t=Number.POSITIVE_INFINITY;e.forEach(o=>{const l=this._keyToItem.get(o),u=this.tileInfoView.getTileScale(l.key);P.has(u)||(P.set(u,[]),s=Math.max(u,s),t=Math.min(u,t)),P.get(u).push(l.key),M.add(u)});let r=this.state.scale;P.has(r)||(he(x,M),x.sort((o,l)=>o-l),r=x.reduce((o,l)=>Math.abs(l-r)<Math.abs(o-r)?l:o,x[0])),r=Math.min(r,s),r=Math.max(r,t);const d=P.get(r),a=i.getClosestInfoForScale(r),c=a.getColumnForX(this.state.center[0]),h=a.getRowForY(this.state.center[1]);return d.sort((o,l)=>{const u=a.denormalizeCol(o.col,o.world),m=a.denormalizeCol(l.col,l.world);return Math.sqrt((c-u)*(c-u)+(h-o.row)*(h-o.row))-Math.sqrt((c-m)*(c-m)+(h-l.row)*(h-l.row))}),M.clear(),P.clear(),d[0].id}_peekByCenterFirst(e){if(!this.state)return e.values().next().value;const i=this.tileInfoView,s=this.state.center;let t,r=Number.POSITIVE_INFINITY;return e.forEach(d=>{const a=this._keyToItem.get(d);i.getTileCoords(B,a.key);const c=Q(B,s);c<r&&(r=c,t=a.key)}),t.id}};g([_({constructOnly:!0})],k.prototype,"concurrency",void 0),g([_({constructOnly:!0})],k.prototype,"process",void 0),g([_()],k.prototype,"state",void 0),g([_({constructOnly:!0})],k.prototype,"strategy",void 0),g([_({constructOnly:!0})],k.prototype,"tileInfoView",void 0),g([_({readOnly:!0})],k.prototype,"updating",null),k=g([G("esri.views.2d.tiling.PagedTileQueue")],k);function ae(n,e){return n.length=0,e.forEach(i=>n.push(i)),n}const E=new Set,V=[],b=new Map,K=[0,0];let v=class extends X{constructor(n){super(n),this._keyToItem=new Map,this.concurrency=6,this.strategy="scale-first",this.tileInfoView=null}initialize(){const{concurrency:n,process:e,strategy:i}=this;this._queue=new U({concurrency:n,process:(s,t)=>{const r=this._keyToItem.get(s);return e(r,{signal:t})},peeker:i==="scale-first"?s=>this._peekByScaleFirst(s):s=>this._peekByCenterFirst(s)})}destroy(){this.clear(),this._queue=j(this._queue)}get length(){return this._queue?this._queue.length:0}get onGoingCount(){return this._keyToItem.size}get updating(){return this.length>0||this.onGoingCount>0}abort(n){const e=typeof n=="string"?n:n.id;this._queue.abort(e)}clear(){this._queue.clear(),this._keyToItem.clear(),this.notifyChange("updating")}has(n){return typeof n=="string"?this._keyToItem.has(n):this._keyToItem.has(n.id)}isOngoing(n){const e=typeof n=="string"?n:n.id;return this.has(e)&&this._queue.isOngoing(e)}pause(){this._queue.pause()}push(n){const e=n.key.id;if(this._queue.has(e))return this._queue.get(e);const i=this._queue.push(e),s=()=>{this._keyToItem.delete(e),this.notifyChange("updating")};return this._keyToItem.set(e,n),i.then(s,s),this.notifyChange("updating"),i}reset(){this._queue.reset()}resume(){this._queue.resume()}_peekByScaleFirst(n){if(!this.state)return n.values().next().value;const e=this.tileInfoView;let i=Number.NEGATIVE_INFINITY,s=Number.POSITIVE_INFINITY;n.forEach(h=>{const o=this._keyToItem.get(h),l=this.tileInfoView.getTileScale(o.key);b.has(l)||(b.set(l,[]),i=Math.max(l,i),s=Math.min(l,s)),b.get(l).push(o.key),E.add(l)});let t=this.state.scale;b.has(t)||(ae(V,E),V.sort((h,o)=>h-o),t=V.reduce((h,o)=>Math.abs(o-t)<Math.abs(h-t)?o:h,V[0])),t=Math.min(t,i),t=Math.max(t,s);const r=b.get(t),d=e.getClosestInfoForScale(t),a=d.getColumnForX(this.state.center[0]),c=d.getRowForY(this.state.center[1]);return r.sort((h,o)=>{const l=d.denormalizeCol(h.col,h.world),u=d.denormalizeCol(o.col,o.world);return Math.sqrt((a-l)*(a-l)+(c-h.row)*(c-h.row))-Math.sqrt((a-u)*(a-u)+(c-o.row)*(c-o.row))}),E.clear(),b.clear(),r[0].id}_peekByCenterFirst(n){if(!this.state)return n.values().next().value;const e=this.tileInfoView,i=this.state.center;let s,t=Number.POSITIVE_INFINITY;return n.forEach(r=>{const d=this._keyToItem.get(r);e.getTileCoords(K,d.key);const a=Q(K,i);a<t&&(t=a,s=d.key)}),s.id}};g([_({constructOnly:!0})],v.prototype,"concurrency",void 0),g([_({constructOnly:!0})],v.prototype,"process",void 0),g([_()],v.prototype,"state",void 0),g([_({constructOnly:!0})],v.prototype,"strategy",void 0),g([_({constructOnly:!0})],v.prototype,"tileInfoView",void 0),g([_({readOnly:!0})],v.prototype,"updating",null),v=g([G("esri.views.2d.tiling.TileQueue")],v);const _e=v;class ce{constructor(e,i,s){this.maxSize=e,this._tileInfoView=i,this._removedFunc=s,this._tilePerId=new Map,this._tileKeysPerLevel=[]}has(e){return this._tilePerId.has(e)}get(e){return this._tilePerId.get(e)}pop(e){const i=this._tilePerId.get(e);if(!i)return;const s=i.key.level,t=this._tileKeysPerLevel[s];L(this._tilePerId,e);for(let r=0;r<t.length;r++)if(t[r].id===e){t.splice(r,1);break}return i.visible=!0,i}add(e){e.visible=!1;const i=e.key,s=i.id;if(this._tilePerId.has(s))return;this._tilePerId.set(s,e);const t=i.level;this._tileKeysPerLevel[t]||(this._tileKeysPerLevel[t]=[]),this._tileKeysPerLevel[t].push(i)}prune(e,i,s){let t=this._tilePerId.size;if(t<=this.maxSize)return;let r=this._tileKeysPerLevel.length-1;for(;t>this.maxSize&&r>=0;)r!==e&&(t=this._pruneAroundCenterTile(t,i,s,r)),r--;t>this.maxSize&&(t=this._pruneAroundCenterTile(t,i,s,e))}_pruneAroundCenterTile(e,i,s,t){const r=this._tileKeysPerLevel[t];if(!r||r.length===0)return e;const{size:d,origin:a}=this._tileInfoView.tileInfo,c=s*d[0],h=s*d[1],o=[0,0],l=[0,0];for(r.sort((u,m)=>(o[0]=a.x+c*(u.col+.5),o[1]=a.y-h*(u.row+.5),l[0]=a.x+c*(m.col+.5),l[1]=a.y-h*(m.row+.5),R(o,i)-R(l,i)));r.length>0;){const u=r.pop();if(this._removeTile(u.id),--e===this.maxSize)break}return e}_removeTile(e){const i=this._tilePerId.get(e);this._removedFunc&&i&&this._removedFunc(i),L(this._tilePerId,e)}}function L(n,e){n.delete(e)}const C=new te(0,0,0,0),f=new Map,q=[],F=[];class Ie{constructor(e){this._previousScale=Number.POSITIVE_INFINITY,this.cachePolicy="keep",this.coveragePolicy="closest",this.resampling=!0,this.tileIndex=new Map,this.tiles=[],this.buffer=192,this.acquireTile=e.acquireTile,this.releaseTile=e.releaseTile,this.tileInfoView=e.tileInfoView,this.resampling=e.resampling==null||!!e.resampling,e.cachePolicy&&(this.cachePolicy=e.cachePolicy),e.coveragePolicy&&(this.coveragePolicy=e.coveragePolicy),e.buffer!=null&&(this.buffer=e.buffer),e.cacheSize&&(this._tileCache=new ce(e.cacheSize,this.tileInfoView,i=>{this.releaseTile(i)}))}destroy(){this.tileIndex.clear()}update(e){const{resampling:i,tileIndex:s}=this,t=this.tileInfoView.getTileCoverage(e.state,this.buffer,this.coveragePolicy);if(F.length=0,q.length=0,f.clear(),!t)return;const{minScale:r,maxScale:d}=this.tileInfoView.tileInfo,{spans:a,lodInfo:c}=t,{level:h}=c,{scale:o,center:l,resolution:u}=e.state,m=!e.stationary&&o>this._previousScale;if(this._previousScale=o,this.tiles.length=0,!i&&(o>r||o<d))return this.tiles.length=0,f.clear(),s.forEach(y=>{this.releaseTile(y)}),s.clear(),F.length=0,q.length=0,f.clear(),A.pool.release(t),!0;s.forEach(y=>y.visible=!0);let O=0,$=0;if(a.length>0)for(const{row:y,colFrom:p,colTo:S}of a)for(let w=p;w<=S;w++){O++;const I=C.set(h,y,c.normalizeCol(w),c.getWorldForColumn(w)).id;if(s.has(I)){const T=s.get(I);T.isReady?(f.set(I,T),$++):m||this._addParentTile(I,f)}else{let T;if(this._tileCache&&this._tileCache.has(I)){if(T=this._tileCache.pop(I),this.tileIndex.set(I,T),T.isReady){f.set(I,T),$++;continue}}else T=this.acquireTile(C),this.tileIndex.set(I,T);m||this._addParentTile(I,f)}}const z=$===O;s.forEach((y,p)=>{if(C.set(p),f.has(p))return;const S=this.tileInfoView.intersects(t,C),w=this.cachePolicy==="purge"?C.level!==h:C.level>h;!S||!m&&z?!w&&S||q.push(p):y.isReady?w&&this.cachePolicy==="purge"&&this._hasReadyAncestor(C,h)?q.push(p):F.push(p):w&&q.push(p)});for(const y of F){const p=s.get(y);p&&p.isReady&&f.set(y,p)}for(const y of q){const p=s.get(y);this._tileCache?this._tileCache.add(p):this.releaseTile(p),s.delete(y)}return f.forEach(y=>this.tiles.push(y)),s.forEach(y=>{f.has(y.key.id)||(y.visible=!1)}),this._tileCache&&this._tileCache.prune(h,l,u),A.pool.release(t),f.clear(),z}clear(e=!0){const{tileIndex:i}=this;e&&i.forEach(s=>{this.releaseTile(s)}),i.clear()}updateCacheSize(e){this._tileCache&&(this._tileCache.maxSize=e)}_addParentTile(e,i){let s=e,t=null;for(;s=this.tileInfoView.getTileParentId(s),s;)if(this.tileIndex.has(s)){if(t=this.tileIndex.get(s),t&&t.isReady){i.has(t.key.id)||i.set(t.key.id,t);break}}else if(this._tileCache&&this._tileCache.has(s)&&(t=this._tileCache.pop(s),this.tileIndex.set(s,t),t&&t.isReady)){i.has(t.key.id)||i.set(t.key.id,t);break}}_hasReadyAncestor(e,i){const s=Y();this.tileInfoView.getTileBounds(s,e,!0);for(const t of this.tileIndex.values())if(t.isReady&&t.key.level>=i&&t.key.level<e.level){const r=Y();if(this.tileInfoView.getTileBounds(r,t.key,!0),ee(r,s))return!0}return!1}}export{re as c,ne as i,W as n,Ie as r,N as t,_e as y};
