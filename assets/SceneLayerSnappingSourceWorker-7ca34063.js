import{cZ as Rt,da as z,n as K,b4 as y,eU as B,f$ as Y,eM as tt,g0 as Et,eT as N,eZ as m,g1 as et,eK as W,e as At,a as Nt,aw as Ft,g as ot,fE as Mt,f7 as v}from"./index-c754ff65.js";import{v as St,b as xt,j as Bt}from"./lineSegment-0ce1b23d.js";import{s as mt,d as it,_ as D,p as nt,T as G,k as F,V as st,R as x,N as rt}from"./sphere-e071b683.js";import{D as at}from"./QueryEngineResult-888a2dd5.js";import"./plane-ad6642df.js";import{i as ht}from"./Util-f53b4bf3.js";import{m as jt}from"./edgeProcessing-9c2e029e.js";import"./byteSizeEstimations-90c5a50d.js";import"./mat3f64-221ce671.js";import"./mat4f64-1413b4a7.js";import"./quatf64-3363c48e.js";import"./vec2f64-22afc56f.js";import"./quantizationUtils-193e54d0.js";import"./ItemCache-096925bc.js";import"./WhereClause-34fdade7.js";import"./executionError-fb3f283a.js";import"./utils-20ac23cf.js";import"./generateRendererUtils-d368e258.js";import"./projectionSupport-60e6d2f8.js";import"./json-48e3ea08.js";import"./utils-c4d70fec.js";import"./normalizeUtils-703059af.js";import"./normalizeUtilsCommon-258cba9f.js";import"./utils-3b5f5c5a.js";import"./featureConversionUtils-c00360ef.js";import"./aaBoundingRect-5c57438c.js";import"./OptimizedGeometry-9aa8664b.js";import"./OptimizedFeatureSet-1d1ac4b9.js";import"./deduplicate-2d736977.js";import"./Indices-c19c78d2.js";import"./InterleavedLayout-ae95d3d9.js";import"./BufferView-f455266d.js";import"./vec2-bbd3449a.js";import"./types-e1c0a5bf.js";import"./VertexAttribute-15d1866a.js";import"./enums-64ab819c.js";import"./VertexElementDescriptor-2925c6af.js";function pt(i){return i?{ray:it(i.ray),c0:i.c0,c1:i.c1}:{ray:it(),c0:0,c1:Number.MAX_VALUE}}new mt(()=>pt());function $(i,t){for(let e=0;e<X.NUM;e++){const o=i[e];if(o[0]*t[0]+o[1]*t[1]+o[2]*t[2]+o[3]>=t[3])return!1}return!0}var dt,c;(function(i){i[i.LEFT=0]="LEFT",i[i.RIGHT=1]="RIGHT",i[i.BOTTOM=2]="BOTTOM",i[i.TOP=3]="TOP",i[i.NEAR=4]="NEAR",i[i.FAR=5]="FAR"})(dt||(dt={})),function(i){i[i.NEAR_BOTTOM_LEFT=0]="NEAR_BOTTOM_LEFT",i[i.NEAR_BOTTOM_RIGHT=1]="NEAR_BOTTOM_RIGHT",i[i.NEAR_TOP_RIGHT=2]="NEAR_TOP_RIGHT",i[i.NEAR_TOP_LEFT=3]="NEAR_TOP_LEFT",i[i.FAR_BOTTOM_LEFT=4]="FAR_BOTTOM_LEFT",i[i.FAR_BOTTOM_RIGHT=5]="FAR_BOTTOM_RIGHT",i[i.FAR_TOP_RIGHT=6]="FAR_TOP_RIGHT",i[i.FAR_TOP_LEFT=7]="FAR_TOP_LEFT"}(c||(c={}));c.FAR_BOTTOM_RIGHT,c.NEAR_BOTTOM_RIGHT,c.NEAR_BOTTOM_LEFT,c.FAR_BOTTOM_LEFT,c.NEAR_BOTTOM_LEFT,c.NEAR_BOTTOM_RIGHT,c.NEAR_TOP_RIGHT,c.NEAR_TOP_LEFT,c.FAR_BOTTOM_RIGHT,c.FAR_BOTTOM_LEFT,c.FAR_TOP_LEFT,c.FAR_TOP_RIGHT,c.NEAR_BOTTOM_RIGHT,c.FAR_BOTTOM_RIGHT,c.FAR_TOP_RIGHT,c.NEAR_TOP_RIGHT,c.FAR_BOTTOM_LEFT,c.NEAR_BOTTOM_LEFT,c.NEAR_TOP_LEFT,c.FAR_TOP_LEFT,c.FAR_TOP_LEFT,c.NEAR_TOP_LEFT,c.NEAR_TOP_RIGHT,c.FAR_TOP_RIGHT;var X,ct;(function(i){i[i.NUM=6]="NUM"})(X||(X={})),function(i){i[i.NUM=8]="NUM"}(ct||(ct={}));new mt(pt);class j{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(t,e){this._objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new l,this._objectCount=0,e&&(e.maximumObjectsPerNode!==void 0&&(this._maximumObjectsPerNode=e.maximumObjectsPerNode),e.maximumDepth!==void 0&&(this._maximumDepth=e.maximumDepth))}destroy(){this._degenerateObjects.clear(),l.clearPool(),Z[0]=null,M.prune(),S.prune()}add(t,e=t.length){this._objectCount+=e,this._grow(t,e);const o=l.acquire();for(let n=0;n<e;n++){const s=t[n];this._isDegenerate(s)?this._degenerateObjects.add(s):(o.init(this._root),this._add(s,o))}l.release(o)}remove(t,e=null){this._objectCount-=t.length;const o=l.acquire();for(const n of t){const s=K(e)?e:D(this._objectToBoundingSphere(n),vt);P(s[3])?(o.init(this._root),this._remove(n,s,o)):this._degenerateObjects.delete(n)}l.release(o),this._shrink()}update(t,e){if(!P(e[3])&&this._isDegenerate(t))return;const o=zt(t);this.remove(o,e),this.add(o)}forEachAlongRay(t,e,o){const n=nt(t,e);this._forEachNode(this._root,s=>{if(!this._intersectsNode(n,s))return!1;const a=s.node;return a.terminals.forAll(h=>{this._intersectsObject(n,h)&&o(h)}),a.residents!==null&&a.residents.forAll(h=>{this._intersectsObject(n,h)&&o(h)}),!0})}forEachAlongRayWithVerticalOffset(t,e,o,n){const s=nt(t,e);this._forEachNode(this._root,a=>{if(!this._intersectsNodeWithOffset(s,a,n))return!1;const h=a.node;return h.terminals.forAll(r=>{this._intersectsObjectWithOffset(s,r,n)&&o(r)}),h.residents!==null&&h.residents.forAll(r=>{this._intersectsObjectWithOffset(s,r,n)&&o(r)}),!0})}forEach(t){this._forEachNode(this._root,e=>{const o=e.node;return o.terminals.forAll(t),o.residents!==null&&o.residents.forAll(t),!0}),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,e,o,n=()=>!0,s=1/0){let a=1/0,h=1/0,r=null;const d=V(t,e),_=u=>{if(--s,!n(u))return;const p=this._objectToBoundingSphere(u);if(!$(o,p))return;const b=A(t,e,F(p)),I=b-p[3],f=b+p[3];I<a&&(a=I,h=f,r=u)};return this._forEachNodeDepthOrdered(this._root,u=>{if(s<=0||!$(o,u.bounds)||(y(g,d,u.halfSize),B(g,g,u.bounds),A(t,e,g)>h))return!1;const p=u.node;return p.terminals.forAll(b=>_(b)),p.residents!==null&&p.residents.forAll(b=>_(b)),!0},t,e),r}forEachInDepthRange(t,e,o,n,s,a,h){let r=-1/0,d=1/0;const _={setRange:f=>{o===j.DepthOrder.FRONT_TO_BACK?(r=Math.max(r,f.near),d=Math.min(d,f.far)):(r=Math.max(r,-f.far),d=Math.min(d,-f.near))}};_.setRange(n);const u=A(e,o,t),p=V(e,o),b=V(e,-o),I=f=>{if(!h(f))return;const E=this._objectToBoundingSphere(f),L=F(E),Q=A(e,o,L)-u,gt=Q-E[3],bt=Q+E[3];gt>d||bt<r||!$(a,E)||s(f,_)};this._forEachNodeDepthOrdered(this._root,f=>{if(!$(a,f.bounds)||(y(g,p,f.halfSize),B(g,g,f.bounds),A(e,o,g)-u>d)||(y(g,b,f.halfSize),B(g,g,f.bounds),A(e,o,g)-u<r))return!1;const E=f.node;return E.terminals.forAll(L=>I(L)),E.residents!==null&&E.residents.forAll(L=>I(L)),!0},e,o)}forEachNode(t){this._forEachNode(this._root,e=>t(e.node,e.bounds,e.halfSize))}forEachNeighbor(t,e){const o=G(e),n=F(e),s=r=>{const d=this._objectToBoundingSphere(r),_=G(d),u=o+_;return!(Y(F(d),n)-u*u<=0)||t(r)};let a=!0;const h=r=>{a&&(a=s(r))};this._forEachNode(this._root,r=>{const d=G(r.bounds),_=o+d;if(Y(F(r.bounds),n)-_*_>0)return!1;const u=r.node;return u.terminals.forAll(h),a&&u.residents!==null&&u.residents.forAll(h),a}),a&&this.forEachDegenerateObject(h)}_intersectsNode(t,e){return C(e.bounds,2*-e.halfSize,T),C(e.bounds,2*e.halfSize,O),ht(t.origin,t.direction,T,O)}_intersectsNodeWithOffset(t,e,o){return C(e.bounds,2*-e.halfSize,T),C(e.bounds,2*e.halfSize,O),o.applyToMinMax(T,O),ht(t.origin,t.direction,T,O)}_intersectsObject(t,e){const o=this._objectToBoundingSphere(e);return!(o[3]>0)||st(o,t)}_intersectsObjectWithOffset(t,e,o){const n=this._objectToBoundingSphere(e);return!(n[3]>0)||st(o.applyToBoundingSphere(n),t)}_forEachNode(t,e){let o=l.acquire().init(t);const n=[o];for(;n.length!==0;){if(o=n.pop(),e(o)&&!o.isLeaf())for(let s=0;s<o.node.children.length;s++)o.node.children[s]&&n.push(l.acquire().init(o).advance(s));l.release(o)}}_forEachNodeDepthOrdered(t,e,o,n=j.DepthOrder.FRONT_TO_BACK){let s=l.acquire().init(t);const a=[s];for(Pt(o,n,_t);a.length!==0;){if(s=a.pop(),e(s)&&!s.isLeaf())for(let h=7;h>=0;--h){const r=_t[h];s.node.children[r]&&a.push(l.acquire().init(s).advance(r))}l.release(s)}}_remove(t,e,o){M.clear();const n=o.advanceTo(e,(s,a)=>{M.push(s.node),M.push(a)})?o.node.terminals:o.node.residents;if(n.removeUnordered(t),n.length===0)for(let s=M.length-2;s>=0;s-=2){const a=M.data[s],h=M.data[s+1];if(!this._purge(a,h))break}}_nodeIsEmpty(t){if(t.terminals.length!==0)return!1;if(t.residents!==null)return t.residents.length===0;for(let e=0;e<t.children.length;e++)if(t.children[e])return!1;return!0}_purge(t,e){return e>=0&&(t.children[e]=null),!!this._nodeIsEmpty(t)&&(t.residents===null&&(t.residents=new z({shrink:!0})),!0)}_add(t,e){e.advanceTo(this._objectToBoundingSphere(t))?e.node.terminals.push(t):(e.node.residents.push(t),e.node.residents.length>this._maximumObjectsPerNode&&e.depth<this._maximumDepth&&this._split(e))}_split(t){const e=t.node.residents;t.node.residents=null;for(let o=0;o<e.length;o++){const n=l.acquire().init(t);this._add(e.getItemAt(o),n),l.release(n)}}_grow(t,e){if(e!==0&&(lt(t,e,o=>this._objectToBoundingSphere(o),R),P(R[3])&&!this._fitsInsideTree(R)))if(this._nodeIsEmpty(this._root.node))D(R,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const o=this._rootBoundsForRootAsSubNode(R);this._placingRootViolatesMaxDepth(o)?this._rebuildTree(R,o):this._growRootAsSubNode(o),l.release(o)}}_rebuildTree(t,e){tt(q,e.bounds),q[3]=e.halfSize,lt([t,q],2,n=>n,U);const o=l.acquire().init(this._root);this._root.initFrom(null,U,U[3]),this._root.increaseHalfSize(1.25),this._forEachNode(o,n=>(this.add(n.node.terminals.data,n.node.terminals.length),n.node.residents!==null&&this.add(n.node.residents.data,n.node.residents.length),!0)),l.release(o)}_placingRootViolatesMaxDepth(t){const e=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let o=0;return this._forEachNode(this._root,n=>(o=Math.max(o,n.depth),o+e<=this._maximumDepth)),o+e>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const e=t[3],o=t;let n=-1/0;const s=this._root.bounds,a=this._root.halfSize;for(let r=0;r<3;r++){const d=s[r]-a-(o[r]-e),_=o[r]+e-(s[r]+a),u=Math.max(0,Math.ceil(d/(2*a))),p=Math.max(0,Math.ceil(_/(2*a)))+1,b=2**Math.ceil(Math.log(u+p)*Math.LOG2E);n=Math.max(n,b),H[r].min=u,H[r].max=p}for(let r=0;r<3;r++){let d=H[r].min,_=H[r].max;const u=(n-(d+_))/2;d+=Math.ceil(u),_+=Math.floor(u);const p=s[r]-a-d*a*2;k[r]=p+(_+d)*a}const h=n*a;return k[3]=h*Ot,l.acquire().initFrom(null,k,h,0)}_growRootAsSubNode(t){const e=this._root.node;tt(R,this._root.bounds),R[3]=this._root.halfSize,this._root.init(t),t.advanceTo(R,null,!0),t.node.children=e.children,t.node.residents=e.residents,t.node.terminals=e.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(t===-1)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(this._root.node.terminals.length!==0||this._root.isLeaf())return-1;let t=null;const e=this._root.node.children;let o=0,n=0;for(;n<e.length&&t==null;)o=n++,t=e[o];for(;n<e.length;)if(e[n++])return-1;return o}_isDegenerate(t){return!P(this._objectToBoundingSphere(t)[3])}_fitsInsideTree(t){const e=this._root.bounds,o=this._root.halfSize;return t[3]<=o&&t[0]>=e[0]-o&&t[0]<=e[0]+o&&t[1]>=e[1]-o&&t[1]<=e[1]+o&&t[2]>=e[2]-o&&t[2]<=e[2]+o}}class l{constructor(){this.bounds=x(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(t,e,o,n=this.depth){return this.node=K(t)?t:l.createEmptyNode(),K(e)&&D(e,this.bounds),this.halfSize=o,this.depth=n,this}increaseHalfSize(t){this.halfSize*=t,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*Ot}advance(t){let e=this.node.children[t];e||(e=l.createEmptyNode(),this.node.children[t]=e),this.node=e,this.halfSize/=2,this.depth++;const o=Tt[t];return this.bounds[0]+=o[0]*this.halfSize,this.bounds[1]+=o[1]*this.halfSize,this.bounds[2]+=o[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(t,e,o=!1){for(;;){if(this.isTerminalFor(t))return e&&e(this,-1),!0;if(this.isLeaf()){if(!o)return e&&e(this,-1),!1;this.node.residents=null}const n=this._childIndex(t);e&&e(this,n),this.advance(n)}}isLeaf(){return this.node.residents!=null}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const e=this.bounds;return(e[0]<t[0]?1:0)+(e[1]<t[1]?2:0)+(e[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new z({shrink:!0}),residents:new z({shrink:!0})}}static acquire(){return l._pool.acquire()}static release(t){l._pool.release(t)}static clearPool(){l._pool.prune()}}function It(i,t){i[0]=Math.min(i[0],t[0]-t[3]),i[1]=Math.min(i[1],t[1]-t[3]),i[2]=Math.min(i[2],t[2]-t[3])}function Lt(i,t){i[0]=Math.max(i[0],t[0]+t[3]),i[1]=Math.max(i[1],t[1]+t[3]),i[2]=Math.max(i[2],t[2]+t[3])}function C(i,t,e){e[0]=i[0]+t,e[1]=i[1]+t,e[2]=i[2]+t}function lt(i,t,e,o){if(t===1){const n=e(i[0]);D(n,o)}else{T[0]=1/0,T[1]=1/0,T[2]=1/0,O[0]=-1/0,O[1]=-1/0,O[2]=-1/0;for(let n=0;n<t;n++){const s=e(i[n]);P(s[3])&&(It(T,s),Lt(O,s))}Et(o,T,O,.5),o[3]=Math.max(O[0]-T[0],O[1]-T[1],O[2]-T[2])/2}}function Pt(i,t,e){if(!S.length)for(let o=0;o<8;++o)S.push({index:0,distance:0});for(let o=0;o<8;++o){const n=Tt[o];S.data[o].index=o,S.data[o].distance=A(i,t,n)}S.sort((o,n)=>o.distance-n.distance);for(let o=0;o<8;++o)e[o]=S.data[o].index}function V(i,t){let e,o=1/0;for(let n=0;n<8;++n){const s=A(i,t,ut[n]);s<o&&(o=s,e=ut[n])}return e}function A(i,t,e){return t*(i[0]*e[0]+i[1]*e[1]+i[2]*e[2])}function P(i){return!isNaN(i)&&i!==-1/0&&i!==1/0&&i>0}l._pool=new Rt(l),function(i){var t;(t=i.DepthOrder||(i.DepthOrder={}))[t.FRONT_TO_BACK=1]="FRONT_TO_BACK",t[t.BACK_TO_FRONT=-1]="BACK_TO_FRONT"}(j||(j={}));const Tt=[m(-1,-1,-1),m(1,-1,-1),m(-1,1,-1),m(1,1,-1),m(-1,-1,1),m(1,-1,1),m(-1,1,1),m(1,1,1)],ut=[m(-1,-1,-1),m(-1,-1,1),m(-1,1,-1),m(-1,1,1),m(1,-1,-1),m(1,-1,1),m(1,1,-1),m(1,1,1)],Ot=Math.sqrt(3),Z=[null];function zt(i){return Z[0]=i,Z}const k=x(),g=N(),T=N(),O=N(),M=new z,vt=x(),R=x(),q=x(),U=x(),H=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],S=new z,_t=[0,0,0,0,0,0,0,0],ft=j,$t=1e3;function Ct(i,t,e){const o=x(),n=F(o);return et(n,n,i,.5),et(n,n,t,.5),o[3]=W(n,i),B(n,n,e),o}let J=class{constructor(){this._idToComponent=new Map,this._components=new ft(i=>i.bounds),this._edges=new ft(i=>i.bounds),this._tmpLineSegment=St(),this._tmpP1=N(),this._tmpP2=N(),this._tmpP3=N(),this.remoteClient=null}async fetchCandidates(i,t){await Promise.resolve(),Ft(t),await this._ensureEdgeLocations(i,t);const e=[];return this._edges.forEachNeighbor(o=>(this._addCandidates(i,o,e),e.length<$t),i.bounds),{result:{candidates:e}}}async _ensureEdgeLocations(i,t){const e=[];if(this._components.forEachNeighbor(s=>{if(ot(s.info)){const{id:a,uid:h}=s;e.push({id:a,uid:h})}return!0},i.bounds),!e.length)return;const o={components:e},n=await this.remoteClient.invoke("fetchAllEdgeLocations",o,Mt(t,{}));for(const s of n.components)this._setFetchEdgeLocations(s)}async add(i){const t=new w(i.id,i.bounds);return this._idToComponent.set(t.id,t),this._components.add([t]),{result:{}}}async remove(i){const t=this._idToComponent.get(i.id);if(t){const e=[];this._edges.forEachNeighbor(o=>(o.component===t&&e.push(o),!0),t.bounds),this._edges.remove(e),this._components.remove([t]),this._idToComponent.delete(t.id)}return{result:{}}}_setFetchEdgeLocations(i){const t=this._idToComponent.get(i.id);if(ot(t)||i.uid!==t.uid)return;const e=jt.createView(i.locations),o=new Array(e.count),n=N(),s=N();for(let r=0;r<e.count;r++){e.position0.getVec(r,n),e.position1.getVec(r,s);const d=Ct(n,s,i.origin),_=new Ht(t,r,d);o[r]=_}this._edges.add(o);const{objectIds:a,origin:h}=i;t.info={locations:e,objectIds:a,origin:h}}_addCandidates(i,t,e){const{info:o}=t.component,{origin:n,objectIds:s}=o,a=o.locations,h=a.position0.getVec(t.index,this._tmpP1),r=a.position1.getVec(t.index,this._tmpP2);B(h,h,n),B(r,r,n);const d=s[a.componentIndex.get(t.index)];this._addEdgeCandidate(i,d,h,r,e),this._addVertexCandidate(i,d,h,e),this._addVertexCandidate(i,d,r,e)}_addEdgeCandidate(i,t,e,o,n){if(!(i.types&at.EDGE))return;const s=F(i.bounds),a=xt(e,o,this._tmpLineSegment),h=Bt(a,s,this._tmpP3);rt(i.bounds,h)&&n.push({type:"edge",objectId:t,target:v(h),distance:W(s,h),start:v(e),end:v(o)})}_addVertexCandidate(i,t,e,o){if(!(i.types&at.VERTEX))return;const n=F(i.bounds);rt(i.bounds,e)&&o.push({type:"vertex",objectId:t,target:v(e),distance:W(n,e)})}};J=At([Nt("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],J);const Ee=J;class w{constructor(t,e){this.id=t,this.bounds=e,this.info=null,this.uid=++w.uid}}w.uid=0;class Ht{constructor(t,e,o){this.component=t,this.index=e,this.bounds=o}}export{Ee as default};
