import{bt as z,ey as N,bz as U,g,el as v,dl as A,dm as G,aO as q,aF as E,ez as J,cW as B,cz as C,cC as _,_ as Z,n as k}from"./index-c754ff65.js";import{v as P}from"./normalizeUtils-703059af.js";import{g as j,m as y,M as I,j as p,C as K,K as V,q as D}from"./featureConversionUtils-c00360ef.js";import{t as S}from"./OptimizedGeometry-9aa8664b.js";import{f as F,g as M}from"./projectionSupport-60e6d2f8.js";const L=new z({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),x=Object.freeze({}),$=new S,T=new S,R=new S,l={esriGeometryPoint:p,esriGeometryPolyline:K,esriGeometryPolygon:V,esriGeometryMultipoint:D};function at(t,r,a,n=t.hasZ,e=t.hasM){if(g(r))return null;const o=t.hasZ&&n,s=t.hasM&&e;if(a){const i=y(R,r,t.hasZ,t.hasM,"esriGeometryPoint",a,n,e);return p(i,o,s)}return p(r,o,s)}function st(t,r,a,n,e,o,s=r,i=a){var d,w,h;const u=r&&s,f=a&&i,c=k(n)?"coords"in n?n:n.geometry:null;if(g(c))return null;if(e){let m=j(T,c,r,a,t,e,s,i);return o&&(m=y(R,m,u,f,t,o)),((d=l[t])==null?void 0:d.call(l,m,u,f))??null}if(o){const m=y(R,c,r,a,t,o,s,i);return((w=l[t])==null?void 0:w.call(l,m,u,f))??null}return I($,c,r,a,s,i),((h=l[t])==null?void 0:h.call(l,$,u,f))??null}async function ot(t,r,a){const{outFields:n,orderByFields:e,groupByFieldsForStatistics:o,outStatistics:s}=t;if(n)for(let i=0;i<n.length;i++)n[i]=n[i].trim();if(e)for(let i=0;i<e.length;i++)e[i]=e[i].trim();if(o)for(let i=0;i<o.length;i++)o[i]=o[i].trim();if(s)for(let i=0;i<s.length;i++)s[i].onStatisticField&&(s[i].onStatisticField=s[i].onStatisticField.trim());return t.geometry&&!t.outSR&&(t.outSR=t.geometry.spatialReference),W(t,r,a)}async function W(t,r,a){var o;if(!t)return null;let{where:n}=t;if(t.where=n=n&&n.trim(),(!n||/^1 *= *1$/.test(n)||r&&r===n)&&(t.where=null),!t.geometry)return t;let e=await H(t);if(t.distance=0,t.units=null,t.spatialRel==="esriSpatialRelEnvelopeIntersects"){const{spatialReference:s}=t.geometry;e=N(e),e.spatialReference=s}if(e){await F(e.spatialReference,a),e=X(e,a);const s=(await P(U(e)))[0];if(g(s))throw x;const i="quantizationParameters"in t&&((o=t.quantizationParameters)==null?void 0:o.tolerance)||"maxAllowableOffset"in t&&t.maxAllowableOffset||0,u=i&&O(e,a)?{densificationStep:8*i}:void 0,f=s.toJSON(),c=await M(f,f.spatialReference,a,u);if(!c)throw x;c.spatialReference=a,t.geometry=c}return t}function O(t,r){if(!t)return!1;const a=t.spatialReference;return(v(t)||A(t)||G(t))&&!q(a,r)&&!E(a,r)}function X(t,r){const a=t.spatialReference;return O(t,r)&&v(t)?{spatialReference:a,rings:[[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]]]}:t}async function H(t){const{distance:r,units:a}=t,n=t.geometry;if(r==null||"vertexAttributes"in n)return n;const e=n.spatialReference,o=a?L.fromJSON(a):J(e),s=e&&(B(e)||C(e))?n:await F(e,_).then(()=>M(n,_));return(await Q())(s.spatialReference,s,r,o)}async function Q(){return(await Z(()=>import("./geometryEngineJSON-1e940afe.js"),["assets/geometryEngineJSON-1e940afe.js","assets/geometryEngineBase-e1a33b0a.js","assets/geometryEngineJSON-3f330436.js","assets/json-48e3ea08.js"])).geodesicBuffer}function lt(t){return t&&b in t?JSON.parse(JSON.stringify(t,Y)):t}const b="_geVersion",Y=(t,r)=>t!==b?r:void 0;export{lt as E,x as F,W as J,at as b,st as v,ot as z};
